// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// Defines values for DeploymentInfoStatus.
const (
	DeploymentInfoStatusRunning  DeploymentInfoStatus = "running"
	DeploymentInfoStatusStarting DeploymentInfoStatus = "starting"
	DeploymentInfoStatusStopping DeploymentInfoStatus = "stopping"
)

// Defines values for ErrorDeploymentInfoPreviousStatus.
const (
	ErrorDeploymentInfoPreviousStatusStarting ErrorDeploymentInfoPreviousStatus = "starting"
	ErrorDeploymentInfoPreviousStatusStopping ErrorDeploymentInfoPreviousStatus = "stopping"
)

// Defines values for RetryDeploymentRequestAction.
const (
	Delete    RetryDeploymentRequestAction = "delete"
	Deploy    RetryDeploymentRequestAction = "deploy"
	Terminate RetryDeploymentRequestAction = "terminate"
)

// Defines values for StatusResponseStatus.
const (
	StatusResponseStatusError    StatusResponseStatus = "error"
	StatusResponseStatusRunning  StatusResponseStatus = "running"
	StatusResponseStatusStarting StatusResponseStatus = "starting"
	StatusResponseStatusStopping StatusResponseStatus = "stopping"
)

// AdminDeployRequest defines model for AdminDeployRequest.
type AdminDeployRequest struct {
	// Category The category of the challenge to deploy.
	Category string `json:"category"`

	// ChallengeName The name of the challenge to deploy.
	ChallengeName string `json:"challenge_name"`
}

// BulkOperationResponse defines model for BulkOperationResponse.
type BulkOperationResponse struct {
	Challenges      []ChallengeCategoryResponse `json:"challenges"`
	ChallengesCount int                         `json:"challenges_count"`
	Message         string                      `json:"message"`
}

// ChallengeCategoryResponse defines model for ChallengeCategoryResponse.
type ChallengeCategoryResponse struct {
	Category      string `json:"category"`
	ChallengeName string `json:"challenge_name"`
}

// DeployRequest defines model for DeployRequest.
type DeployRequest struct {
	// Category The category of the challenge to deploy.
	Category string `json:"category"`

	// ChallengeName The name of the challenge to deploy.
	ChallengeName string `json:"challenge_name"`
}

// DeploymentInfo defines model for DeploymentInfo.
type DeploymentInfo struct {
	Category       string  `json:"category"`
	ChallengeName  string  `json:"challenge_name"`
	ConnectionInfo *string `json:"connection_info,omitempty"`

	// DeployedDurationSeconds Duration in seconds since deployment started.
	DeployedDurationSeconds int `json:"deployed_duration_seconds"`

	// DeployedSince The time the deployment was created.
	DeployedSince time.Time `json:"deployed_since"`

	// ExpiresAt When the deployment expires. Null for unique deployments.
	ExpiresAt *time.Time           `json:"expires_at,omitempty"`
	Status    DeploymentInfoStatus `json:"status"`
}

// DeploymentInfoStatus defines model for DeploymentInfo.Status.
type DeploymentInfoStatus string

// Error defines model for Error.
type Error struct {
	Message *string `json:"message,omitempty"`
}

// ErrorDeploymentInfo defines model for ErrorDeploymentInfo.
type ErrorDeploymentInfo struct {
	Category      string `json:"category"`
	ChallengeName string `json:"challenge_name"`

	// CreatedAt When the deployment was created.
	CreatedAt time.Time `json:"created_at"`

	// ErrorMessage The error message from the failed deployment.
	ErrorMessage string `json:"error_message"`

	// Id The deployment ID.
	Id int `json:"id"`

	// PreviousStatus The status before the deployment transitioned to error. Indicates whether a deploy or terminate action was in progress.
	PreviousStatus ErrorDeploymentInfoPreviousStatus `json:"previous_status"`

	// TeamId The team identifier. Empty string for unique/admin deployments.
	TeamId string `json:"team_id"`

	// UpdatedAt When the deployment was last updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// ErrorDeploymentInfoPreviousStatus The status before the deployment transitioned to error. Indicates whether a deploy or terminate action was in progress.
type ErrorDeploymentInfoPreviousStatus string

// RetryDeploymentRequest defines model for RetryDeploymentRequest.
type RetryDeploymentRequest struct {
	// Action The action to perform - 'deploy' to retry deployment, 'terminate' to terminate the failed deployment, 'delete' to remove the deployment from the database. If not provided, the action will be inferred from the previous status (deploy or terminate only).
	Action *RetryDeploymentRequestAction `json:"action,omitempty"`

	// DeploymentId The ID of the deployment to retry.
	DeploymentId int `json:"deployment_id"`
}

// RetryDeploymentRequestAction The action to perform - 'deploy' to retry deployment, 'terminate' to terminate the failed deployment, 'delete' to remove the deployment from the database. If not provided, the action will be inferred from the previous status (deploy or terminate only).
type RetryDeploymentRequestAction string

// StatusResponse defines model for StatusResponse.
type StatusResponse struct {
	ConnectionInfo *string    `json:"connection_info,omitempty"`
	ExpirationTime *time.Time `json:"expiration_time,omitempty"`

	// ExtensionTime Time duration each extension adds (e.g., "30m", "1h").
	ExtensionTime *string `json:"extension_time,omitempty"`

	// ExtensionsLeft Number of extensions left for this deployment. -1 if unlimited.
	ExtensionsLeft *int                  `json:"extensions_left,omitempty"`
	Status         *StatusResponseStatus `json:"status,omitempty"`

	// Unique Whether this is a unique deployment or not.
	Unique *bool `json:"unique,omitempty"`
}

// StatusResponseStatus defines model for StatusResponse.Status.
type StatusResponseStatus string

// TeamDeploymentsResponse defines model for TeamDeploymentsResponse.
type TeamDeploymentsResponse struct {
	Deployments []DeploymentInfo `json:"deployments"`

	// TeamId The team identifier. Empty string for unique/admin deployments.
	TeamId string `json:"team_id"`
}

// DeployAdminInstanceJSONRequestBody defines body for DeployAdminInstance for application/json ContentType.
type DeployAdminInstanceJSONRequestBody = AdminDeployRequest

// RetryDeploymentJSONRequestBody defines body for RetryDeployment for application/json ContentType.
type RetryDeploymentJSONRequestBody = RetryDeploymentRequest

// TerminateAdminInstanceJSONRequestBody defines body for TerminateAdminInstance for application/json ContentType.
type TerminateAdminInstanceJSONRequestBody = AdminDeployRequest

// DeployInstanceJSONRequestBody defines body for DeployInstance for application/json ContentType.
type DeployInstanceJSONRequestBody = DeployRequest

// TerminateInstanceJSONRequestBody defines body for TerminateInstance for application/json ContentType.
type TerminateInstanceJSONRequestBody = DeployRequest

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Check communication with Zync
	// (POST /admin/config-check)
	ConfigCheck(ctx echo.Context) error
	// Deploy a unique challenge (admin only)
	// (POST /admin/deploy)
	DeployAdminInstance(ctx echo.Context) error
	// Deploy all unique challenges (admin only)
	// (POST /admin/deploy-all)
	DeployAllAdminInstances(ctx echo.Context) error
	// List all deployments in error status (admin only)
	// (GET /admin/error-deployments)
	ListErrorDeployments(ctx echo.Context) error
	// List all unique challenges
	// (GET /admin/list-unique-challs)
	ListUniqueChallenges(ctx echo.Context) error
	// Reload challenges index
	// (POST /admin/reload-challs)
	ReloadChallenges(ctx echo.Context) error
	// Retry a failed deployment (admin only)
	// (POST /admin/retry-deployment)
	RetryDeployment(ctx echo.Context) error
	// List all deployments grouped by team (admin only)
	// (GET /admin/team-deployments)
	ListTeamDeployments(ctx echo.Context) error
	// Terminate a unique challenge (admin only)
	// (POST /admin/terminate)
	TerminateAdminInstance(ctx echo.Context) error
	// Terminate all unique challenges (admin only)
	// (POST /admin/terminate-all)
	TerminateAllAdminInstances(ctx echo.Context) error
	// Deploy a challenge instance
	// (POST /deploy)
	DeployInstance(ctx echo.Context) error
	// Extend the duration of a deployment
	// (POST /extend)
	ExtendInstance(ctx echo.Context) error
	// Health check
	// (GET /health)
	GetHealth(ctx echo.Context) error
	// Get deployment status
	// (GET /status)
	GetInstanceStatus(ctx echo.Context) error
	// Terminate a challenge instance
	// (POST /terminate)
	TerminateInstance(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// ConfigCheck converts echo context to params.
func (w *ServerInterfaceWrapper) ConfigCheck(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ConfigCheck(ctx)
	return err
}

// DeployAdminInstance converts echo context to params.
func (w *ServerInterfaceWrapper) DeployAdminInstance(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeployAdminInstance(ctx)
	return err
}

// DeployAllAdminInstances converts echo context to params.
func (w *ServerInterfaceWrapper) DeployAllAdminInstances(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeployAllAdminInstances(ctx)
	return err
}

// ListErrorDeployments converts echo context to params.
func (w *ServerInterfaceWrapper) ListErrorDeployments(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListErrorDeployments(ctx)
	return err
}

// ListUniqueChallenges converts echo context to params.
func (w *ServerInterfaceWrapper) ListUniqueChallenges(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListUniqueChallenges(ctx)
	return err
}

// ReloadChallenges converts echo context to params.
func (w *ServerInterfaceWrapper) ReloadChallenges(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ReloadChallenges(ctx)
	return err
}

// RetryDeployment converts echo context to params.
func (w *ServerInterfaceWrapper) RetryDeployment(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.RetryDeployment(ctx)
	return err
}

// ListTeamDeployments converts echo context to params.
func (w *ServerInterfaceWrapper) ListTeamDeployments(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListTeamDeployments(ctx)
	return err
}

// TerminateAdminInstance converts echo context to params.
func (w *ServerInterfaceWrapper) TerminateAdminInstance(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TerminateAdminInstance(ctx)
	return err
}

// TerminateAllAdminInstances converts echo context to params.
func (w *ServerInterfaceWrapper) TerminateAllAdminInstances(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TerminateAllAdminInstances(ctx)
	return err
}

// DeployInstance converts echo context to params.
func (w *ServerInterfaceWrapper) DeployInstance(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeployInstance(ctx)
	return err
}

// ExtendInstance converts echo context to params.
func (w *ServerInterfaceWrapper) ExtendInstance(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ExtendInstance(ctx)
	return err
}

// GetHealth converts echo context to params.
func (w *ServerInterfaceWrapper) GetHealth(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetHealth(ctx)
	return err
}

// GetInstanceStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetInstanceStatus(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetInstanceStatus(ctx)
	return err
}

// TerminateInstance converts echo context to params.
func (w *ServerInterfaceWrapper) TerminateInstance(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TerminateInstance(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.POST(baseURL+"/admin/config-check", wrapper.ConfigCheck)
	router.POST(baseURL+"/admin/deploy", wrapper.DeployAdminInstance)
	router.POST(baseURL+"/admin/deploy-all", wrapper.DeployAllAdminInstances)
	router.GET(baseURL+"/admin/error-deployments", wrapper.ListErrorDeployments)
	router.GET(baseURL+"/admin/list-unique-challs", wrapper.ListUniqueChallenges)
	router.POST(baseURL+"/admin/reload-challs", wrapper.ReloadChallenges)
	router.POST(baseURL+"/admin/retry-deployment", wrapper.RetryDeployment)
	router.GET(baseURL+"/admin/team-deployments", wrapper.ListTeamDeployments)
	router.POST(baseURL+"/admin/terminate", wrapper.TerminateAdminInstance)
	router.POST(baseURL+"/admin/terminate-all", wrapper.TerminateAllAdminInstances)
	router.POST(baseURL+"/deploy", wrapper.DeployInstance)
	router.POST(baseURL+"/extend", wrapper.ExtendInstance)
	router.GET(baseURL+"/health", wrapper.GetHealth)
	router.GET(baseURL+"/status", wrapper.GetInstanceStatus)
	router.POST(baseURL+"/terminate", wrapper.TerminateInstance)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"/wAekp4PLwAA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
